//#region imports
// import * as dockernode from 'dockerode';
import { ChangeOfFile } from 'incremental-compiler/src';
import { config } from 'tnp-config/src';
import { CoreModels, crossPlatformPath, path } from 'tnp-core/src';
import { fse } from 'tnp-core/src';
import { _ } from 'tnp-core/src';
import { Helpers, UtilsTypescript } from 'tnp-helpers/src';
import {
  BaseFeatureForProject,
  BaseDebounceCompilerForProject,
} from 'tnp-helpers/src';

import {
  DEFAULT_PORT,
  DOCKER_COMPOSE_FILE_NAME,
  DOCKER_FOLDER,
  MIGRATION_CONST_PREFIX,
  migrationIndexAutogeneratedTsFileRelativeToSrcPath,
  THIS_IS_GENERATED_INFO_COMMENT,
  USE_IN_HOST_CONFIG_FULL_CONTEXT_PATH,
  USE_MIGRATIONS_DATA_IN_HOST_CONFIG,
} from '../../../../../constants';
import { Models } from '../../../../../models';
import {
  Development,
  EnvOptions,
  ReleaseArtifactTaonNames,
} from '../../../../../options';
import { Project } from '../../../project';
//#endregion

/**
 * handle dockers image in taon projects
 */
export class AppHostsRecreateHelper extends BaseDebounceCompilerForProject<
  {
    envOptions: EnvOptions;
  }, // @ts-ignore TODO weird inheritance problem
  Project
> {
  //#region constructor
  private readonly baseSrcFolder: string;
  private lastTaonContexts: Models.TaonContext[] = [];
  private lastMigrationExported: UtilsTypescript.ExportInfo[] = [];
  constructor(project: Project) {
    super(project, {
      folderPath: [project.pathFor([config.folder.src])],
      subscribeOnlyFor: ['ts', 'tsx'],
      followSymlinks: false,
      taskName: 'AppHostsTsRecreateHelper',
      notifyOnFileUnlink: true,
    });
    this.baseSrcFolder = project.pathFor('src') + '/';
  }
  //#endregion

  //#region getters
  get envOptions(): EnvOptions {
    return this.initialParams.envOptions;
  }

  //#endregion

  //#region rebuild
  private async rebuild(
    changeOfFiles: ChangeOfFile[],
    asyncEvent: boolean,
  ): Promise<void> {
    //#region @backendFunc

    Helpers.taskStarted(`Rebuilding app.hosts.ts`);
    // if (asyncEvent) {
    //   console.log('ASYNC EVNET changeOfFiles', changeOfFiles);
    //   // console.log('env release', this.envOptions.release);
    // } else {
    //   console.log('SYNC EVNET changeOfFiles', changeOfFiles);
    // }
    const taonContexts = this.project.framework.getAllDetectedTaonContexts();
    const migrationExported = USE_MIGRATIONS_DATA_IN_HOST_CONFIG
      ? UtilsTypescript.exportsFromFile(
          this.project.pathFor([
            config.folder.src,
            migrationIndexAutogeneratedTsFileRelativeToSrcPath,
          ]),
        ).filter(c => c.type === 'const') || []
      : [];

    if (
      this.lastTaonContexts?.length > 0 &&
      _.isEqual(taonContexts, this.lastTaonContexts) &&
      (USE_MIGRATIONS_DATA_IN_HOST_CONFIG
        ? _.isEqual(migrationExported, this.lastMigrationExported)
        : true)
    ) {
      Helpers.logInfo(`No need for taon context update in app.hosts `);
      return;
    }
    this.lastTaonContexts = taonContexts;
    this.lastMigrationExported = migrationExported;

    this.writePortsToFile();
    await this.updatePortsInHosts(this.envOptions);

    Helpers.taskDone(`Rebuilding app.hosts.ts Done`);
    //#endregion
  }
  async action({
    changeOfFiles,
    asyncEvent,
  }: {
    changeOfFiles: ChangeOfFile[];
    asyncEvent: boolean;
  }): Promise<void> {
    //#region @backendFunc
    changeOfFiles = changeOfFiles.filter(c => {
      const relativePath = c.fileAbsolutePath.replace(this.baseSrcFolder, '');
      return this.project.framework.contextFilter(relativePath);
    });
    if (changeOfFiles.length === 0) {
      Helpers.logInfo(`No file detected that affects app.hosts.ts`);
      return;
    }
    await this.rebuild(changeOfFiles, asyncEvent);
    //#endregion
  }
  //#endregion

  //#region private methods / write ports to file
  public writePortsToFile(): void {
    // #region @backend
    Helpers.taskStarted('Writing hosts and ports config to app.hosts ...');
    const appHostsFile = crossPlatformPath(
      path.join(this.project.location, config.folder.src, 'app.hosts.ts'),
    );
    const filesWithContexts = {} as { [fileRelativePath: string]: string[] };
    const migrationExported: UtilsTypescript.ExportInfo[] =
      this.lastMigrationExported;

    const contexts = this.lastTaonContexts.filter(
      f =>
        f.fileRelativePath.startsWith('app/') ||
        f.fileRelativePath.startsWith('app.'),
    );

    // console.log({ taonContexts });
    for (const context of contexts) {
      if (!filesWithContexts[context.fileRelativePath]) {
        filesWithContexts[context.fileRelativePath] = [];
      }
      filesWithContexts[context.fileRelativePath].push(context.contextName);
    }
    let counter = 0;

    const tempalte = (n?: number) => {
      return (
        `
/**
 * Your context backend port
 * ${!n ? '@deprecated use HOST_BACKEND_PORT_n instead' : ''}
 */
export const HOST_BACKEND_PORT${n ? `_${n}` : ''} = ` +
        `${this.prefixVarTemplate('HOST_BACKEND_PORT', n) + (n ? `undefined` : 'HOST_BACKEND_PORT_1')};
/**
 * Angular website url with normal/nodejs backend
 * ${!n ? '@deprecated use FRONTEND_NORMAL_APP_PORT_n instead' : ''}
 */
export const FRONTEND_NORMAL_APP_PORT${n ? `_${n}` : ''} = ` +
        `${this.prefixVarTemplate('FRONTEND_NORMAL_APP_PORT', n, { sameAsFirstInDevMode: true }) + (n ? `undefined` : 'FRONTEND_NORMAL_APP_PORT_1')};

/**
 * @deprecated use FRONTEND_NORMAL_APP_PORT instead
*/
export const CLIENT_DEV_NORMAL_APP_PORT${n ? `_${n}` : ''} = FRONTEND_NORMAL_APP_PORT${n ? `_${n}` : ''};

/**
 * Angular website url with websql backend
 * ${!n ? '@deprecated use FRONTEND_WEBSQL_APP_PORT_n instead' : ''}
 */
export const FRONTEND_WEBSQL_APP_PORT${n ? `_${n}` : ''} = ` +
        `${this.prefixVarTemplate('FRONTEND_WEBSQL_APP_PORT', n, { sameAsFirstInDevMode: true }) + (n ? `undefined` : 'FRONTEND_WEBSQL_APP_PORT_1')};

/**
 * @deprecated use FRONTEND_WEBSQL_APP_PORT instead
*/
export const CLIENT_DEV_WEBSQL_APP_PORT${n ? `_${n}` : ''} = FRONTEND_WEBSQL_APP_PORT${n ? `_${n}` : ''};

/**
 * Electron/angular website url for electron app purpose (ipc backend)
 */
export const FRONTEND_NORMAL_ELECTRON_PORT${n ? `_${n}` : ''} = ${n ? `undefined` : 'FRONTEND_NORMAL_ELECTRON_PORT_1'};
// electron websql not supported yet
// export const FRONTEND_WEBSQL_ELECTRON_PORT${n ? `_${n}` : ''} = ${n ? `undefined` : 'FRONTEND_WEBSQL_ELECTRON_PORT_1'};
/**
 * Backend url - use as "host" inside your context
 * ${!n ? '@deprecated use HOST_URL_n instead' : ''}
 */
export const HOST_URL${n ? `_${n}` : ''} =  ${this.prefixVarTemplate('HOST_URL', n, { isURL: true })} ('http://localhost:' + HOST_BACKEND_PORT${n ? `_${n}` : ''});
/**
 * Frontend host url - use as "frontendHost" inside your context
 * ${!n ? '@deprecated use FRONTEND_HOST_URL_n instead' : ''}
 */
export const FRONTEND_HOST_URL${n ? `_${n}` : ''} = ${this.prefixVarTemplate('FRONTEND_HOST_URL', n, { isURL: true, sameAsFirstInDevMode: true })}  ( 'http://localhost:' +
  (isWebSQLMode ? FRONTEND_WEBSQL_APP_PORT${n ? `_${n}` : ''} : FRONTEND_NORMAL_APP_PORT${n ? `_${n}` : ''}));
/**
 * Frontend electron host url - use in app.electron.ts with win.loadURL(FRONTEND_HOST_URL_ELECTRON);
 */
export const FRONTEND_HOST_URL_ELECTRON${n ? `_${n}` : ''} = 'http://localhost:' + FRONTEND_NORMAL_ELECTRON_PORT${n ? `_${n}` : ''}
// electron websql not supported yet
// export const FRONTEND_HOST_URL_ELECTRON${n ? `_${n}` : ''} =
//  'http://localhost:' +
//  (isWebSQLMode ? FRONTEND_WEBSQL_ELECTRON_PORT${n ? `_${n}` : ''} : FRONTEND_NORMAL_ELECTRON_PORT${n ? `_${n}` : ''});

  `
      );
    };
    const depecationMessage = `\n/** @deprecated avoid using HOST_CONFIG inside library code (src/lib/**) */\n`;
    Helpers.writeFile(
      appHostsFile,
      `
${THIS_IS_GENERATED_INFO_COMMENT}
${'imp' + 'ort'} { APP_ID, BUILD_BASE_HREF } from '${'./lib/build-info._auto-generated_'}';
${migrationExported
  .map(
    c =>
      `import { ${c.name} } ` +
      `from './${migrationIndexAutogeneratedTsFileRelativeToSrcPath.replace(/\.ts$/, '')}';`,
  )
  .join('\n')}

let isWebSQLMode: boolean = false;
//#${'reg' + 'ion'} @${'bac' + 'kend'}
isWebSQLMode = false;
//#${'end' + 'reg' + 'ion'}

//#${'reg' + 'ion'} @${'web' + 'sql' + 'Only'}
isWebSQLMode = true;
//#${'end' + 'reg' + 'ion'}

const nodeENV = (()=> {
  let env: any;
  //#${'reg' + 'ion'} @${'bac' + 'kend'}
  env = process.env || {};
  //#${'endr' + 'egion'}
  return env || {};
})();

const windowENV = (()=> {
  let env: any;
  //#${'reg' + 'ion'} @${'bro' + 'wser'}
  env = globalThis['ENV'] || {};
  //#${'endr' + 'egion'}
  return env || {};
})();

const argsENV = (()=> {
  let env: any;
  //#${'reg' + 'ion'} @${'bac' + 'kend'}
  env = require('minimist')(process.argv);
  //#${'endr' + 'egion'}
  return env || {};
})();

const transformURL = (url: string): string => {
  if (!url) {
    return url;
  }
  //#${'reg' + 'ion'} @${'bac' + 'kend'}
  if (url.startsWith('http://') || url.startsWith('https://')) {
    return url;
  }
  return 'http://' + url; // by default backend is http
  //#${'endr' + 'egion'}
  //#${'reg' + 'ion'} @${'bro' + 'wser'}
  if (url.startsWith('http://') || url.startsWith('https://')) {
    return url;
  }
  return globalThis?.location?.protocol + '//' + url;
  //#${'endr' + 'egion'}
};

const ACTIVE_CONTEXT: string | null = nodeENV['ACTIVE_CONTEXT'] || argsENV['ACTIVE_CONTEXT'] || windowENV['ACTIVE_CONTEXT'] || null;

${_.times(contexts.length, i => {
  return tempalte(i + 1);
}).join('\n')}
${
  contexts.length > 0
    ? tempalte()
    : `

export const CLIENT_DEV_NORMAL_APP_PORT = void 0;
export const CLIENT_DEV_WEBSQL_APP_PORT = void 0;
  `
}

export const HOST_CONFIG = {
${Object.keys(filesWithContexts)
  .sort((a, b) => a.localeCompare(b))
  .map((contextFileName, index) => {
    const contextsInFile = (filesWithContexts[contextFileName] || []).sort(
      (a, b) => a.localeCompare(b),
    );
    const contextIsInsideLibInsteadApp = contextFileName.startsWith('lib/');
    if (contextIsInsideLibInsteadApp) {
      return `// Context(s) "${contextsInFile.join(',')}" from /src/lib can't use HOST_CONFIG - only code from /src/app or scr/app.* can use it.`;
    }
    return `
    ${contextIsInsideLibInsteadApp ? depecationMessage : `\n/** Relative file path for context */\n`}
    ${!USE_IN_HOST_CONFIG_FULL_CONTEXT_PATH ? '//' : ''}'${contextFileName}' ${USE_IN_HOST_CONFIG_FULL_CONTEXT_PATH ? `: {` : ''}
${contextsInFile
  .map((contextName, i) => {
    const contextMigraions = migrationExported.find(
      c => c.name.replace(MIGRATION_CONST_PREFIX, '') === contextName,
    )?.name;

    ++counter;

    return `
${contextIsInsideLibInsteadApp ? depecationMessage : `\n/** Name of context (var, let, const variable) inside *.ts file. */\n`}
        '${contextName}': {
        ${contextIsInsideLibInsteadApp ? depecationMessage : ''}
         activeContext: ACTIVE_CONTEXT,
        ${contextIsInsideLibInsteadApp ? depecationMessage : ''}
         contextName: '${contextName}',
        ${contextIsInsideLibInsteadApp ? depecationMessage : ''}
         hostPortNumber: Number(HOST_BACKEND_PORT_${counter}),
         ${contextIsInsideLibInsteadApp ? depecationMessage : ''}
         host: HOST_URL_${counter} + BUILD_BASE_HREF,
         ${contextIsInsideLibInsteadApp ? depecationMessage : ''}
         frontendHostPortNumber: Number(FRONTEND_NORMAL_APP_PORT_${counter}),
         ${contextIsInsideLibInsteadApp ? depecationMessage : ''}
         frontendHost: FRONTEND_HOST_URL_${counter} + BUILD_BASE_HREF,
         ${contextIsInsideLibInsteadApp ? depecationMessage : ''}
         appId: APP_ID,
        ${USE_MIGRATIONS_DATA_IN_HOST_CONFIG ? `//#${'reg' + 'ion'}  @${'web' + 'sql'}` : ''}
         ${USE_MIGRATIONS_DATA_IN_HOST_CONFIG && contextMigraions && contextIsInsideLibInsteadApp ? depecationMessage : ''}
         ${
           USE_MIGRATIONS_DATA_IN_HOST_CONFIG && contextMigraions
             ? `migrations: { ...${contextMigraions} },`
             : USE_MIGRATIONS_DATA_IN_HOST_CONFIG
               ? `// no migrations detected  for this context`
               : ''
         }
        ${USE_MIGRATIONS_DATA_IN_HOST_CONFIG ? `//#${'end' + 'reg' + 'ion'}` : ''}
      }`;
  })
  .map(c => c.trimStart())
  .join(',\n')}${!USE_IN_HOST_CONFIG_FULL_CONTEXT_PATH ? '' : '}'}`;
  })
  .join(',\n')}
}

${THIS_IS_GENERATED_INFO_COMMENT}


      `,
    );
    Helpers.taskDone('Done writing ports and hosts to app.hosts.ts');
    //#endregion
  }
  //#endregion

  //#region prefix var template
  protected prefixVarTemplate(
    varName: string,
    n: number | undefined,
    options?: { isURL?: boolean; sameAsFirstInDevMode?: boolean },
  ): string {
    //#region @backendFunc
    options = options || {};
    let { isURL, sameAsFirstInDevMode } = options;
    isURL = !!isURL;
    sameAsFirstInDevMode = !!sameAsFirstInDevMode;
    const IS_DEV_MODE =
      sameAsFirstInDevMode && n > 1
        ? `(!ACTIVE_CONTEXT ? ${varName}_1 : undefined ) ||`
        : '';
    return (
      `${IS_DEV_MODE} ${isURL ? 'transformURL' : ''}(nodeENV['${varName}${n ? `_${n}` : ''}']) || ` +
      `${isURL ? 'transformURL' : ''}(windowENV['${varName}${n ? `_${n}` : ''}']) || ` +
      `${isURL ? 'transformURL' : ''}(argsENV['${varName}${n ? `_${n}` : ''}']) || `
    );
    //#endregion
  }
  //#endregion

  //#region public methods / update ports in hosts
  public async updatePortsInHosts(buildOptions: EnvOptions): Promise<void> {
    //#region @backendFunc
    let contexts: string[] = [];
    type ContextOptions = {
      num: number;
      contextName: string;
      nodeBeAppPort?: number;
      ngWebsqlAppPort?: number;
      ngWebsqlElectronPort?: number;
      ngNormalAppPort?: number;
      ngNormalElectronPort?: number;
    };

    const contextTemplate = (options: ContextOptions): string => {
      return `###  **${options.contextName}** (#${options.num})
- nodejs backend http://localhost:${options.nodeBeAppPort}
- normal frontend app for nodejs backend http://localhost:${options.ngNormalAppPort}
- websql app backend/frontend http://localhost:${options.ngWebsqlAppPort}
`;
    };

    const allDetectedContexts = this.project.framework
      .getAllDetectedTaonContexts()
      .filter(
        f =>
          f.fileRelativePath.startsWith('app/') ||
          f.fileRelativePath.startsWith('app.'),
      );

    const ONLY_ONE_FRONTEND_IN_DEV = true;
    let ngWebsqlAppPortFirst: number | undefined;
    let ngNormalAppPortFirst: number | undefined;
    let ngWebsqlElectronPortFirst: number | undefined;
    let ngNormalElectronPortFirst: number | undefined;

    for (let i = 0; i < allDetectedContexts.length; i++) {
      const nodeBeAppPort = await this.NODE_BACKEND_PORT_UNIQ_KEY(
        buildOptions.clone({
          build: {
            websql: false,
          },
          release: {
            targetArtifact: 'angular-node-app',
          },
        }),
        i + 1,
      );
      const ngWebsqlAppPort =
        ONLY_ONE_FRONTEND_IN_DEV && ngWebsqlAppPortFirst
          ? ngWebsqlAppPortFirst
          : await this.APP_NG_SERVE_ARTIFACT_PORT_UNIQ_KEY(
              buildOptions.clone({
                build: {
                  websql: true,
                },
                release: {
                  targetArtifact: 'angular-node-app',
                },
              }),
              {
                num: i + 1,
              },
            );
      ngWebsqlAppPortFirst = ngWebsqlAppPortFirst || ngWebsqlAppPort;

      const ngNormalAppPort =
        ONLY_ONE_FRONTEND_IN_DEV && ngNormalAppPortFirst
          ? ngNormalAppPortFirst
          : await this.APP_NG_SERVE_ARTIFACT_PORT_UNIQ_KEY(
              buildOptions.clone({
                build: {
                  websql: false,
                },
                release: {
                  targetArtifact: 'angular-node-app',
                },
              }),
              {
                num: i + 1,
              },
            );

      ngNormalAppPortFirst = ngNormalAppPortFirst || ngNormalAppPort;

      const ngWebsqlElectronPort =
        ONLY_ONE_FRONTEND_IN_DEV && ngWebsqlElectronPortFirst
          ? ngWebsqlElectronPortFirst
          : await this.APP_NG_SERVE_ARTIFACT_PORT_UNIQ_KEY(
              buildOptions.clone({
                build: {
                  websql: true,
                },
                release: {
                  targetArtifact: 'electron-app',
                },
              }),
              {
                num: i + 1,
              },
            );
      ngWebsqlElectronPortFirst =
        ngWebsqlElectronPortFirst || ngWebsqlElectronPortFirst;

      const ngNormalElectronPort =
        ONLY_ONE_FRONTEND_IN_DEV && ngNormalElectronPortFirst
          ? ngNormalElectronPortFirst
          : await this.APP_NG_SERVE_ARTIFACT_PORT_UNIQ_KEY(
              buildOptions.clone({
                build: {
                  websql: false,
                },
                release: {
                  targetArtifact: 'electron-app',
                },
              }),
              {
                num: i + 1,
              },
            );
      ngNormalElectronPortFirst =
        ngNormalElectronPortFirst || ngNormalElectronPort;

      contexts.push(
        contextTemplate({
          num: i + 1,
          contextName: allDetectedContexts[i].contextName,
          nodeBeAppPort,
          ngWebsqlAppPort,
          ngWebsqlElectronPort,
          ngNormalAppPort,
          ngNormalElectronPort,
        }),
      );

      UtilsTypescript.setValueToVariableInTsFile(
        this.project.pathFor('src/app.hosts.ts'),
        'HOST_BACKEND_PORT_' + (i + 1),
        this.prefixVarTemplate('HOST_BACKEND_PORT', i + 1) + nodeBeAppPort,
        {
          useRawStringValue: true,
        },
      );

      UtilsTypescript.setValueToVariableInTsFile(
        this.project.pathFor('src/app.hosts.ts'),
        'FRONTEND_WEBSQL_APP_PORT_' + (i + 1),
        this.prefixVarTemplate('FRONTEND_WEBSQL_APP_PORT', i + 1) +
          ngWebsqlAppPort,
        {
          useRawStringValue: true,
        },
      );

      UtilsTypescript.setValueToVariableInTsFile(
        this.project.pathFor('src/app.hosts.ts'),
        'FRONTEND_NORMAL_APP_PORT_' + (i + 1),
        this.prefixVarTemplate('FRONTEND_NORMAL_APP_PORT', i + 1) +
          ngNormalAppPort,
        {
          useRawStringValue: true,
        },
      );

      // TODO electron websql not supported yet
      // UtilsTypescript.setValueToVariableInTsFile(
      //   this.project.pathFor('src/app.hosts.ts'),
      //   'FRONTEND_WEBSQL_ELECTRON_PORT_' + (i + 1),
      //   ngWebsqlElectronPort,
      // );

      UtilsTypescript.setValueToVariableInTsFile(
        this.project.pathFor('src/app.hosts.ts'),
        'FRONTEND_NORMAL_ELECTRON_PORT_' + (i + 1),
        ngNormalElectronPort,
      );
    }

    this.project.writeFile(
      'BUILD-INFO.md',
      `# CURRENT BUILD INFO

Project name: **${this.project.name}** <br>
Project npm name: **${this.project.nameForNpmPackage}**

## All contexts (detected = ${allDetectedContexts.length})

${contexts.join('\n')}
`,
    );
    //#endregion
  }
  //#endregion

  //#region public methods / get ng server unique key
  async APP_NG_SERVE_ARTIFACT_PORT_UNIQ_KEY(
    buildOptions: Partial<EnvOptions>,
    options?: {
      num?: number;
    },
  ): Promise<number> {
    //#region @backendFunc
    options = options || ({} as any);
    const { num } = options;
    buildOptions = EnvOptions.from(buildOptions);
    const key =
      `ng ${buildOptions.release.targetArtifact === 'electron-app' ? 'electron' : 'app'}` +
      ` (${buildOptions.build.websql ? 'websql' : 'normal'})` +
      ` # context=${num || 1} `;
    return await this.project.registerAndAssignPort(key, {
      startFrom: DEFAULT_PORT.APP_BUILD_LOCALHOST,
    });
    //#endregion
  }
  //#endregion

  //#region public methods / get node backend unique key
  async NODE_BACKEND_PORT_UNIQ_KEY(
    buildOptions: EnvOptions,
    num?: Number,
  ): Promise<number> {
    buildOptions = EnvOptions.from(buildOptions);
    const key = `node backend${num ? ` (${num})` : ''}`;
    return await this.project.registerAndAssignPort(key, {
      startFrom: DEFAULT_PORT.SERVER_LOCALHOST,
    });
  }
  //#endregion
}
